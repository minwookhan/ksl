<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="minwook Han" />
  <title>프로젝트 설명 AIThread 영상 처리 및 gRPC 통신 과정 분석</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">프로젝트 설명 AIThread 영상 처리 및 gRPC 통신 과정
분석</h1>
<p class="author">minwook Han</p>
</header>
<h1 id="python-code-실행-과정과-시간-유추">python code 실행 과정과 시간
유추</h1>
<p>`ksl-cli`는 <strong><strong>FHD (1920x1080)</strong></strong> 원본
영상을 입력받더라도, 내부 로직에 의해 **가로 320px**로 리사이징된
데이터를 주로 처리하고 전송합니다.</p>
<p>다음은 데이터 흐름에 따른 각 단계별 함수와 처리되는 데이터의 크기
분석입니다. <strong>(가정: ROI를 설정하지 않고 1920x1080 전체를
처리한다고 가정할 때)</strong></p>
<p>—</p>
<h2 id="영상-로드-video-loading">1. 영상 로드 (Video Loading)</h2>
<p>가장 처음 비디오 파일에서 원본 프레임을 읽어오는 단계입니다.</p>
<h3 id="사용-함수-cv2.videocapture.read-opencv"><strong><strong>사용
함수</strong></strong>: `cv2.VideoCapture.read()` (OpenCV)</h3>
<h3 id="입력-데이터-mp4-비디오-파일-스트림"><strong><strong>입력
데이터</strong></strong>: MP4 비디오 파일 스트림</h3>
<h3 id="출력-데이터-raw"><strong><strong>출력 데이터
(Raw)</strong></strong>:</h3>
<ul>
<li>해상도: <strong><strong>1920 x 1080</strong></strong> (FHD)</li>
<li>채널: 3 (BGR)</li>
<li>*<strong>데이터 크기</strong> *: <span
class="math inline">1920 × 1080 × 3 bytes ≈ <strong>6.22</strong>
MB</span></li>
<li>설명: 압축이 풀린 순수 비트맵 데이터입니다.</li>
</ul>
<h2 id="전처리-preproce-sing---데이터-급감-구간">2. 전처리 (Preproce
sing) - <strong><strong>데이터 급감 구간</strong></strong></h2>
<p>AI 인식 속도 향상과 네트워크 대역폭 절약을 위해 이미지를
축소합니다.</p>
<h3
id="사용-함수-videoloader.preprocessframe-srcvideo.py"><strong><strong>사용
함수</strong></strong>: `VideoLoader.<sub>preprocess</sub>(frame)`
(`src/video.py`)</h3>
<h3 id="주요-로직"><strong><strong>주요 로직</strong></strong>:</h3>
<ol>
<li>ROI Crop (지정된 영역 자르기)</li>
<li><strong><strong>Resize</strong></strong>: 가로 너비가 320px 이상이면
**320px**로 강제 축소 (비율 유지)</li>
<li>Convert: BGR → RGB</li>
</ol>
<h3 id="출력-데이터-processed"><strong><strong>출력 데이터
(Processed)</strong></strong>:</h3>
<ul>
<li>계산: 가로 320px 고정. 16:9 비율 유지 시 세로는 180px.</li>
<li>해상도: <strong><strong>320 x 180</strong></strong></li>
<li>채널: 3 (RGB)</li>
<li><strong><strong>데이터 크기</strong></strong>: <span
class="math inline">320 × 180 × 3
bytes = <strong>172</strong><strong>,</strong> <strong>800</strong>
bytes(≈<strong>168</strong> KB)</span></li>
<li><strong><strong>변화</strong></strong>: 원본 대비 약
<strong><strong>2.7%</strong></strong> 크기로 감소.</li>
</ul>
<h2 id="optical-flow-계산-motion-detection">3. Optical Flow 계산 (Motion
Detection)</h2>
<p>움직임 감지를 위해 흑백 영상을 사용합니다.</p>
<h3
id="사용-함수-calculateopticalflowvalue-srcvideo.py"><strong><strong>사용
함수</strong></strong>: `calculate<sub>opticalflowvalue</sub>`
(`src/video.py`)</h3>
<ul>
<li>내부 호출: `cv2.cvtColor`, `cv2.calcOpticalFlowPyrLK`</li>
</ul>
<h3 id="입력-데이터-전처리된-320x180-rgb-이미지"><strong><strong>입력
데이터</strong></strong>: 전처리된 320x180 RGB 이미지</h3>
<h3 id="변환-데이터-grayscale"><strong><strong>변환 데이터
(Grayscale)</strong></strong>:</h3>
<ul>
<li>해상도: <strong><strong>320 x 180</strong></strong></li>
<li>채널: 1 (Gray)</li>
<li><strong><strong>데이터 크기</strong></strong>: <span
class="math inline">320 × 180 × 1
bytes = <strong>57</strong><strong>,</strong> <strong>600</strong>
bytes(≈<strong>56</strong> KB)</span></li>
</ul>
<h3
id="출력-데이터-float-8-bytes---움직임-평균값-하나만-반환."><strong><strong>출력
데이터</strong></strong>: `float` (8 bytes) - 움직임 평균값 하나만
반환.</h3>
<h2 id="ai-추론-mediapipe-pose">4. AI 추론 (MediaPipe Pose)</h2>
<p>인체 관절 포인트(Skeleton)를 추출합니다.</p>
<h3
id="사용-함수-poseestimator.processframe-srcmain.py"><strong><strong>사용
함수</strong></strong>:
`pose<sub>estimator</sub>.process<sub>frame</sub>` (`src/main.py`)</h3>
<h3 id="입력-데이터-320x180-rgb-이미지-168-kb"><strong><strong>입력
데이터</strong></strong>: 320x180 RGB 이미지 (168 KB)</h3>
<h2 id="출력-데이터-skeleton"><strong><strong>출력 데이터
(Skeleton)</strong></strong>:</h2>
<ul>
<li>구조: 33개의 랜드마크 (각 x, y, z, visibility, presence)</li>
<li><strong><strong>데이터 크기</strong></strong>:
<ul>
<li>33 points <span class="math inline">×</span> 5 floats <span
class="math inline">×</span> 4 bytes <span class="math inline">≈</span>
<strong><strong>660 bytes</strong></strong> (1 KB 미만)</li>
</ul></li>
<li>설명: 이미지 크기에 비해 매우 작습니다.</li>
</ul>
<h2 id="데이터-인코딩-protobuf-encoding">5. 데이터 인코딩 (Protobuf
Encoding)</h2>
<p>서버로 보내기 위해 데이터를 직렬화합니다. <strong><strong>중요:
이미지를 압축(JPEG/PNG)하지 않고 Raw Byte로
보냅니다.</strong></strong></p>
<h3 id="사용-함수-encodeframe-srcnetwork.py"><strong><strong>사용
함수</strong></strong>: `encode<sub>frame</sub>` (`src/network.py`)</h3>
<h3 id="입력-데이터"><strong><strong>입력 데이터</strong></strong>:</h3>
<ol>
<li>이미지: 320x180 RGB Raw Data (168 KB)</li>
<li>스켈레톤: 33 Points (0.6 KB)</li>
<li>메타데이터: Session ID, Index 등 (수십 바이트)</li>
</ol>
<h3 id="출력-데이터-pb2.frame"><strong><strong>출력 데이터
(pb2.Frame)</strong></strong>:</h3>
<ul>
<li><strong><strong>패킷 크기</strong></strong>: <strong><strong>약 170
~ 175 KB</strong></strong> (프레임 당)</li>
<li>설명: `image.tobytes()`를 사용하므로 픽셀 데이터가 그대로
들어갑니다.</li>
</ul>
<h2 id="네트워크-전송-grpc-streaming">6. 네트워크 전송 (gRPC
Streaming)</h2>
<h3
id="사용-함수-grpcclient.sendstream-srcnetwork.py"><strong><strong>사용
함수</strong></strong>: `grpc<sub>client</sub>.send<sub>stream</sub>`
(`src/network.py`)</h3>
<h3
id="전송량-키프레임keyframe으로-선정된-프레임만-전송됩니다."><strong><strong>전송량</strong></strong>:
키프레임(Keyframe)으로 선정된 프레임만 전송됩니다.</h3>
<ul>
<li>만약 1초에 5개의 키프레임이 발생한다면: <span
class="math inline">170 KB × 5 ≈ <strong>850</strong> KB/s</span></li>
</ul>
<p>—</p>
<p>### 요약 테이블</p>
<table>
<tbody>
<tr class="odd">
<td>단계</td>
<td>처리 내용</td>
<td>해상도 / 구조</td>
<td>데이터 크기 (Bytes)</td>
<td>비고</td>
</tr>
<tr class="even">
<td>:—</td>
<td>:—</td>
<td>:—</td>
<td>:—</td>
<td>:—</td>
</tr>
<tr class="odd">
<td><strong><strong>1</strong></strong></td>
<td><strong><strong>원본 로드</strong></strong></td>
<td>1920 x 1080 (3ch)</td>
<td><strong><strong>~6,220,800 (6.2 MB)</strong></strong></td>
<td>`cv2` Read</td>
</tr>
<tr class="even">
<td><strong><strong>2</strong></strong></td>
<td><strong><strong>전처리 (Resize)</strong></strong></td>
<td><strong><strong>320 x 180</strong></strong> (3ch)</td>
<td><strong><strong>172,800 (168 KB)</strong></strong></td>
<td><strong><strong>가장 큰 변화 (강제 축소)</strong></strong></td>
</tr>
<tr class="odd">
<td><strong><strong>3</strong></strong></td>
<td><strong><strong>모션 감지</strong></strong></td>
<td>320 x 180 (1ch)</td>
<td>57,600 (56 KB)</td>
<td>내부 연산용 (전송 X)</td>
</tr>
<tr class="even">
<td><strong><strong>4</strong></strong></td>
<td><strong><strong>AI 데이터</strong></strong></td>
<td>33개 좌표 (Float)</td>
<td>~660 (0.6 KB)</td>
<td>Skeleton</td>
</tr>
<tr class="odd">
<td><strong><strong>5</strong></strong></td>
<td><strong><strong>최종 패킷</strong></strong></td>
<td><strong><strong>Image Raw + AI</strong></strong></td>
<td><strong><strong>~175,000 (170 KB)</strong></strong></td>
<td><strong><strong>실제 전송량 (Per Keyframe)</strong></strong></td>
</tr>
</tbody>
</table>
<p><strong><strong>결론</strong></strong>: FHD 영상을 넣더라도
`ksl-cli`는 내부적으로 **약 170KB 크기의 패킷**으로 가공하여 서버와
통신합니다. 대역폭 산정 시 원본 크기가 아닌 **320x180 해상도 기준**으로
계산해야 합니다.</p>
</body>
</html>
